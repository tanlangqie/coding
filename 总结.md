# -*- coding: utf-8 -*-#

# Name:   递归总结.py
# Author: tangzhuang
# Date:   2021/4/28
# desc:         



############    递归总结 (回溯)    从左往右的尝试模式（打印字符串的全部子序列，打家劫舍、背包）、范围上的尝试模型（n皇后）、多样本位置全对应的尝试模型、寻找业务限制的尝试模型        ############
#左神视频：暴力递归开始https://www.bilibili.com/video/BV14i4y1T7Af?p=27&spm_id_from=pageDriver&vd_source=3675ca51c748da48a05ecd2de032af06
#leetcode题目总结 https://leetcode-cn.com/problems/combination-sum/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-7tum/
递归总结：https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF
回溯总结：https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80

1.如果题目中出现 “所有，全部” 等字样，则代表需要遍历所有可能，此时应该想到递归与回溯（各种排列组合也是回溯，回溯可以画个n叉树帮助理解）。如果题目中还出现了
最大，最小，最长等字眼，则考虑动态规划。常见的递归问题   字符串的全部子序列；字符串的全排列

2.递归中要定义好递归函数的意义（也就是返回值代表的含义），终止条件（或最简单的条件）以及非终止条件的细分情况（eg:1、2阶爬楼梯）。
传参数时候，list类型会每次都变，可以用res存储过程值，返回后求res_list的最值

3.回溯的特点之一是要 穷举 所有的情况；可以用树来对应回溯的过程和所有情况（如下面第5个例题）。需要知道它是几叉树，例如括号生成问题就是二叉树，在对几叉树进行枚举时可以用for循环或直接枚举
其他特点：回溯常常和深度优先遍历、递归结合起来一起用
https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-by-powcai-2/

回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。

作者：LeetCode
链接：https://leetcode-cn.com/problems/two-sum/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


4.在递归中，如果递归结果需要层层传递（即：所有递归只需要一个输出，则应该在fun中return fun ）如下所示
def fun(i, p):
    if i == 3:
        print('i=={}的输出'.format(i))
        return p
    return fun(i+1,p)

p = 5
print(fun(1, p))


5.暴力递归的改进----初版：返回一个列表，在求列表的最值----》改进：直接返回最值  可以参考背包问题.py或者看下面的例子
在初版中，递归函数不返回结果，递归函数只是遍历一遍所有可能，由path记录路径，res统计每条路径的结果，
在改进版本中，递归函数直接返回目标值，递归函数的定义是走到第i个位置能获取的最大，最小，最长···目标值是多少。
import copy

#暴力递归------返回一个列表，在求列表的最值
# def fun(arr,count,i,path,res):
#     # print(id(path))
#     #count代表取了几只股票，如果已经取了两支了，则返回
#     if count == 2:
#         res.append(path)
#         return
#     if i == len(arr):
#         return
#     path = copy.deepcopy(path)    #这里可以用deepcopy 也可以用 path[:]
#     #不要第i个
#     fun(arr,count,i+1,path,res)
#
#     #要第i个
#     path.extend([arr[i]])
#     fun(arr,count+1,i+1,path,res)  #这里可以用deepcopy 也可以用 path[:]+[arr[i]]
#


#暴力递归 改进 --- 不需要列表，直接返回最值
def fun(arr,count,i,path,res):
    # print(id(path))
    if count == 2:
        return path[1] - path[0]
    if i == len(arr):
        return -100
    path = copy.deepcopy(path)
    #不要第i个
    a = fun(arr,count,i+1,path,res)

    #要第i个
    path.extend([arr[i]])
    b = fun(arr,count+1,i+1,path,res)
    return max(a,b)

arr = [2,1,5,7,3]
count = 0
path = []
i = 0
res = []

t = fun(arr,count,i,path,res)
print(t)




############    字符串总结             ############
1.题目涉及 出现次数---》 ‘散列表’
1.题目涉及 子串---》 ‘滑动窗口’










###############   数组总结################
1.需要保存可覆盖位置与观测位置---》双指针（只遍历依次，空间复杂度O(1)）
